// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

package oauthgitlab

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strconv"
	"strings"
	"time"

	"github.com/mattermost/mattermost-server/v6/einterfaces"
	"github.com/mattermost/mattermost-server/v6/model"
)

type GitLabProvider struct {
}

type GitLabUser struct {
	Id       int64  `json:"id"`
	Username string `json:"username"`
	Login    string `json:"login"`
	Email    string `json:"email"`
	Name     string `json:"name"`
}

func init() {

	fmt.Println("------------------------------------ Initializing init moduel oauthgitlab  -------------------------")
	provider := &GitLabProvider{}
	einterfaces.RegisterOAuthProvider(model.UserAuthServiceGitlab, provider)

	providerGoogle := &GooglebProvider{}
	einterfaces.RegisterOAuthProvider(model.UserAuthServiceGoogle, providerGoogle)

	providerOpenid := &OpenidProvider{}
	einterfaces.RegisterOAuthProvider(model.UserAuthServiceOpenid, providerOpenid)
}

func userFromGitLabUser(glu *GitLabUser) *model.User {
	user := &model.User{}
	username := glu.Username
	if username == "" {
		username = glu.Login
	}
	user.Username = model.CleanUsername(username)
	splitName := strings.Split(glu.Name, " ")
	if len(splitName) == 2 {
		user.FirstName = splitName[0]
		user.LastName = splitName[1]
	} else if len(splitName) >= 2 {
		user.FirstName = splitName[0]
		user.LastName = strings.Join(splitName[1:], " ")
	} else {
		user.FirstName = glu.Name
	}
	user.Email = glu.Email
	user.Email = strings.ToLower(user.Email)
	userId := glu.getAuthData()
	user.AuthData = &userId
	user.AuthService = model.UserAuthServiceGitlab

	return user
}

func gitLabUserFromJSON(data io.Reader) (*GitLabUser, error) {
	decoder := json.NewDecoder(data)
	var glu GitLabUser
	err := decoder.Decode(&glu)
	if err != nil {
		return nil, err
	}
	return &glu, nil
}

func (glu *GitLabUser) IsValid() error {
	if glu.Id == 0 {
		return errors.New("user id can't be 0")
	}

	if glu.Email == "" {
		return errors.New("user e-mail should not be empty")
	}

	return nil
}

func (glu *GitLabUser) getAuthData() string {
	return strconv.FormatInt(glu.Id, 10)
}

func (m *GitLabProvider) GetUserFromJSON(data io.Reader, tokenUser *model.User) (*model.User, error) {
	glu, err := gitLabUserFromJSON(data)
	if err != nil {
		return nil, err
	}
	if err = glu.IsValid(); err != nil {
		return nil, err
	}

	return userFromGitLabUser(glu), nil
}

func (m *GitLabProvider) GetSSOSettings(config *model.Config, service string) (*model.SSOSettings, error) {
	return &config.GitLabSettings, nil
}

func (m *GitLabProvider) GetUserFromIdToken(idToken string) (*model.User, error) {
	return nil, nil
}

func (m *GitLabProvider) IsSameUser(dbUser, oauthUser *model.User) bool {
	return dbUser.AuthData == oauthUser.AuthData
}

///////////////////////   For GOOGLE API //////////////////////////

type GooglebProvider struct {
}

type GoogleUser struct {
	Id       string `json:"id"`
	Username string `json:"username"`
	Login    string `json:"login"`
	Email    string `json:"email"`
	Name     string `json:"name"`
}

func userFromGoogleUser(glu *GoogleUser) *model.User {
	fmt.Println("========================== userFromGoogleUser model/gitlab.go ===========================")

	user := &model.User{}
	username := glu.Username
	if username == "" {
		username = glu.Login
	}
	user.Username = model.CleanUsername(username)
	splitName := strings.Split(glu.Name, " ")
	if len(splitName) == 2 {
		user.FirstName = splitName[0]
		user.LastName = splitName[1]
	} else if len(splitName) >= 2 {
		user.FirstName = splitName[0]
		user.LastName = strings.Join(splitName[1:], " ")
	} else {
		user.FirstName = glu.Name
	}
	user.Email = glu.Email
	user.Email = strings.ToLower(user.Email)
	userId := glu.getAuthData()
	user.AuthData = &userId

	user.AuthService = model.UserAuthServiceGoogle

	return user
}

func googleUserFromJSON(data io.Reader) (*GoogleUser, error) {
	fmt.Println("========================== googleUserFromJSON model/gitlab.go ===========================")

	befor := json.NewDecoder(data)
	var auto AutoGenerated
	err := befor.Decode(&auto)
	if err != nil {
		fmt.Println(" Error in parsing: ", err)
	}

	var glu GoogleUser

	// decoder := json.NewDecoder(data)
	// err = decoder.Decode(&glu)
	// if err != nil {
	// 	return nil, err
	// }

	glu.Id = auto.Names[0].Metadata.Source.ID
	glu.Username = auto.Names[0].DisplayName
	glu.Login = auto.Names[0].DisplayName
	glu.Email = auto.EmailAddresses[0].Value
	glu.Name = auto.Names[0].DisplayNameLastFirst

	return &glu, nil
}

func (glu *GoogleUser) IsValid() error {
	if glu.Id == "0" {
		return errors.New("user id can't be 0")
	}

	if glu.Email == "" {
		return errors.New("user e-mail should not be empty")
	}

	return nil
}

func (glu *GoogleUser) getAuthData() string {
	return fmt.Sprint(glu.Id) //strconv.FormatInt(glu.Id, 10) // //
}

func (m *GooglebProvider) GetUserFromJSON(data io.Reader, tokenUser *model.User) (*model.User, error) {
	fmt.Println("========================== GetUserFromJSON model/gitlab.go ===========================")

	glu, err := googleUserFromJSON(data)

	if err != nil {
		return nil, err
	}
	if err = glu.IsValid(); err != nil {
		return nil, err
	}

	return userFromGoogleUser(glu), nil
}

func (m *GooglebProvider) GetSSOSettings(config *model.Config, service string) (*model.SSOSettings, error) {
	return &config.GoogleSettings, nil
}

func (m *GooglebProvider) GetUserFromIdToken(idToken string) (*model.User, error) {
	return nil, nil
}

func (m *GooglebProvider) IsSameUser(dbUser, oauthUser *model.User) bool {
	return dbUser.AuthData == oauthUser.AuthData
}

type AutoGenerated struct {
	ResourceName string `json:"resourceName"`
	Etag         string `json:"etag"`
	Metadata     struct {
		Sources []struct {
			Type            string `json:"type"`
			ID              string `json:"id"`
			Etag            string `json:"etag"`
			ProfileMetadata struct {
				ObjectType string   `json:"objectType"`
				UserTypes  []string `json:"userTypes"`
			} `json:"profileMetadata"`
			UpdateTime time.Time `json:"updateTime"`
		} `json:"sources"`
		ObjectType string `json:"objectType"`
	} `json:"metadata"`
	Names []struct {
		Metadata struct {
			Primary bool `json:"primary"`
			Source  struct {
				Type string `json:"type"`
				ID   string `json:"id"`
			} `json:"source"`
			SourcePrimary bool `json:"sourcePrimary"`
		} `json:"metadata"`
		DisplayName          string `json:"displayName"`
		FamilyName           string `json:"familyName"`
		GivenName            string `json:"givenName"`
		DisplayNameLastFirst string `json:"displayNameLastFirst"`
		UnstructuredName     string `json:"unstructuredName"`
	} `json:"names"`
	EmailAddresses []struct {
		Metadata struct {
			Primary  bool `json:"primary"`
			Verified bool `json:"verified"`
			Source   struct {
				Type string `json:"type"`
				ID   string `json:"id"`
			} `json:"source"`
			SourcePrimary bool `json:"sourcePrimary"`
		} `json:"metadata"`
		Value string `json:"value"`
	} `json:"emailAddresses"`
}

///////////////////////////////////////////////////////// OpenID ////////////////////////////////////////////////////

type OpenidProvider struct {
}

type OpenidUser struct {
	Id       int64  `json:"id"`
	Username string `json:"username"`
	Login    string `json:"login"`
	Email    string `json:"email"`
	Name     string `json:"name"`
}

func userFromOpenidUser(glu *OpenidUser) *model.User {
	user := &model.User{}
	username := glu.Username
	if username == "" {
		username = glu.Login
	}
	user.Username = model.CleanUsername(username)
	splitName := strings.Split(glu.Name, " ")
	if len(splitName) == 2 {
		user.FirstName = splitName[0]
		user.LastName = splitName[1]
	} else if len(splitName) >= 2 {
		user.FirstName = splitName[0]
		user.LastName = strings.Join(splitName[1:], " ")
	} else {
		user.FirstName = glu.Name
	}
	user.Email = glu.Email
	user.Email = strings.ToLower(user.Email)
	userId := glu.getAuthData()
	user.AuthData = &userId
	user.AuthService = model.UserAuthServiceGoogle

	return user
}

func OpenidUserFromJSON(data io.Reader) (*OpenidUser, error) {
	fmt.Println("========================== OpenidUserFromJSON model/gitlab.go ===========================")

	dta, _ := json.Marshal(data)
	fmt.Println("========= data: ", string(dta))

	decoder := json.NewDecoder(data)
	var glu OpenidUser
	err := decoder.Decode(&glu)
	if err != nil {
		return nil, err
	}
	return &glu, nil
}

func (glu *OpenidUser) IsValid() error {
	if glu.Id == 0 {
		return errors.New("user id can't be 0")
	}

	if glu.Email == "" {
		return errors.New("user e-mail should not be empty")
	}

	return nil
}

func (glu *OpenidUser) getAuthData() string {
	return strconv.FormatInt(glu.Id, 10)
}

func (m *OpenidProvider) GetUserFromJSON(data io.Reader, tokenUser *model.User) (*model.User, error) {
	fmt.Println("========================== GetUserFromJSON model/gitlab.go ===========================")

	glu, err := OpenidUserFromJSON(data)
	fmt.Println("========= err: ", err)

	if err != nil {
		return nil, err
	}
	if err = glu.IsValid(); err != nil {
		return nil, err
	}

	return userFromOpenidUser(glu), nil
}

func (m *OpenidProvider) GetSSOSettings(config *model.Config, service string) (*model.SSOSettings, error) {
	return &config.GoogleSettings, nil
}

func (m *OpenidProvider) GetUserFromIdToken(idToken string) (*model.User, error) {
	return nil, nil
}

func (m *OpenidProvider) IsSameUser(dbUser, oauthUser *model.User) bool {
	return dbUser.AuthData == oauthUser.AuthData
}
